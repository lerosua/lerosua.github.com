<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 读书笔记 | 阳光烂灿的日子]]></title>
  <link href="http://lerosua.github.io/blog/categories/du-shu-bi-ji/atom.xml" rel="self"/>
  <link href="http://lerosua.github.io/"/>
  <updated>2017-01-24T14:01:03+08:00</updated>
  <id>http://lerosua.github.io/</id>
  <author>
    <name><![CDATA[lerosua]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《方与圆》读后感(转)]]></title>
    <link href="http://lerosua.github.io/blog/2006/09/19/readbookoffang/"/>
    <updated>2006-09-19T00:00:00+08:00</updated>
    <id>http://lerosua.github.io/blog/2006/09/19/readbookoffang</id>
    <content type="html"><![CDATA[<p><p><!--      @page { size: 21cm 29.7cm; margin: 2cm }        P { margin-bottom: 0.21cm }     --></p>
<p><font color="#6600cc"><br />
<img src="http://www.linuxfans.org/nuke/images/topics/folder.gif" />一篇转文，偶同学写的，他没有博客。所以借地方发表一下。版权为他所有。《方与圆》相信大家<br />
都看过吧，没看过也听过吧！</font></p>
<p>《方与圆》</p>
<p>——读书感悟<br />
------陈钟智</p>
<p>第一次看《方与圆》是在我大学三年级的时候，那时拿到这本书的时候，把它认为和其它的同类型的书一样，没有太多的用处，只是在说空话，事实证明我错了。《方与圆》是我在大学四年里看过的令我有最大利益的书，当年在大学时看《方与圆》已有一些感想，我想在工作半年后再看这本书会有更多的感悟。</p>
<p>书的题目《方与圆》来源于清朝的铜钱——内方外圆，也启示我们做人要内方外圆。方，就是做人的正气，具备优秀的品质。圆，就是处世老练、圆通、善用技巧。这与我们国美的用人标准相似，先用德才兼备的圣人，次之君子。在大三看这本书的时候，我对“方”是极力赞成的，对“圆”却有怀疑的态度，认为做人不必那么假，使用手段，只要真诚就好了。但在工作半年后，我却对“圆”有了更深刻的体会。“方”是做人之本，对人生而言，技巧只是方法和手段，而决定人生成败的却是品质；圆是处世之道，一个人的成功只有百分之十五是依靠专业技术，而百分之八十五却要依靠人际交往，有效说话等软科学本领。在读大学时，我们把大部分的精力放在学习知识上，却忽略了培养能力的重要性，知识本身并不重要，重要的是运用知识。但一个人能力的获得要靠实践的磨练、经验的积累，一个人生活经历越曲折，阅历越丰富，能力就越强。但是，能力强不一定是件好事，如果把能力用在做坏事上，那只能给社会带来危害。一个能否成功的决定性因素正在于他是否具备优秀的品质，而优秀的品质却体现在自信、勇气、热忱上。</p>
<p>自信、勇气、热忱对于一位管理者而言是至关重要的。只有先让自己相信自己，才能让你的员工、顾客相信你。在我刚来门店工作时，对商品的功能、结构都不了解，所以常在顾客面前显得不自信，这样顾客当然不会购买我介绍的商品，但当我熟识了商品知识后，在推销商品时就会变得自信，顾客才会对我介绍的商品有信心，所以说推销商品，首先要推销自己，顾客接受了你，看见你就喜欢，才会接受你的商品，顾客如果不接受你，见到你就讨厌，你的商品再好他们也不会喜欢，而要推销自己，首先就是要有自信，自信也有助你渡过不断的困难和挫折，生活中的许多问题就将迎刃而解了，一量你真正建立了自信，你将发现你整个人都会为之改观，气质会更优秀，能力会更强，随之你的生活态度也将变得更乐观。</p>
<p>勇气，同样也是作为一名管理者所以必须具备的，即使一个人再自信，脑子里有好多好主意，自己总是在想总是在说，却总没有做，就仿佛熔岩在地层运动，但仍没有足够的力量喷发。这就是成功的人和失败的人的区别，不在于主意的好坏，能力的大小，而在于是否相信自己的判断，敢于适度冒险，并采取行动，勇气就是敢做敢为，就是将自信表现在行动中的一种胆识，把自己认为正确的主意，用行动来实现。</p>
<p>热忱就是挚爱工作，人生在历史的长河中，仅仅是短短的一瞬间，只有工作才能产生一种永恒的美丽，为你的存在留下不可磨灭的印记。我认为人生最大的幸福莫过于找到自己倾心相爱的工作，努力做出成绩，在工作中感受创造的欢乐，要工作中体现自己的价值。我相信自己只要在工作中主动积极，不怕苦不怕累，对、对待每项工作都认认真真，那么即使处在世界任何一个不起眼的角落，都终将脱颖而出。</p>
<p><font face="AR PL ShanHeiSun Uni, serif"><br />
</font><font face="AR PL ShanHeiSun Uni, serif">
</font></p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C陷阱与缺陷(3)]]></title>
    <link href="http://lerosua.github.io/blog/2006/05/10/c%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B73/"/>
    <updated>2006-05-10T00:00:00+08:00</updated>
    <id>http://lerosua.github.io/blog/2006/05/10/c陷阱与缺陷3</id>
    <content type="html"><![CDATA[<p>第三章 语义陷阱</p>




<p>3.1<strong>指针与数组</strong></p>




<p>C语言的值得注意的两点</p>




<p>1.C语言只有一堆数组，而且数组的大小必须在编译期就作为一个常数确定下来。因为数组中的元素可以是任何类型的对象，因此也可以是另一个数组。所以多维数组就是这样“仿真”来的。</p>




<p>2.对于一个数组，我们只能够做两件事：确定数组的大小，以及获得指向该数组下标为0的元素的指针。其它有关数组的操作都是通过指针进行的。</p>




<p>*a是数组a中下标为0的元素的引用。*(a+1)即是数组a中下标为1的元素的引用。*(a+i)即数组a中下标为i的元素的引用。而a[i]是上面写法的简记。因为a+i和i+a的含义一样，所以a[i]和i[a]是同一种含义！</p>




<p>对于二维数组 int a[10][13],a则是“数组的数组”。声明指向a的指针的话需要这种形式：int (*p)[13]; 但对于二维数组最好还是使用下标的形式！</p>




<p>3.2<strong>非数组的指针</strong></p>




<p>在C语言中，字符串常量代表了一块包括字符串中所有字符以及一个空字符('\ 0')的内存区域。因为C语言要求字符串常量以空字符作为结束标志。</p>




<p>strlen函数返回的字符个数并未包括空字符，因此在用malloc和strlen结合分配内存时需要加上一个空字符。类似这种状况:</p>




<p>malloc(strlen(s)+1);</p>




<p>3.3<strong>作为参数的数组声明</strong></p>




<p>将数组作为函数参数毫无意义，C语言会自动地将作为参数的数组声明转换为相应的指针声明。</p>




<p><strong>int strlen(char s[]){ }</strong>与<strong> int strlen(char *s){ }</strong>写法相同！</p>




<p><strong>int main(int argc,char **argv){}</strong>与<strong>int main(int argc,*argv[])</strong>等价，但前者强调argv是一个指向某数组的起始元素的指针，该数组的元素为字符指针类型。</p>




<p>3.4<strong>避免“举隅法”</strong></p>




<p>举隅法（synecdoche)以含义更宽泛的词语来代替含义相对较窄的词语，或者相反。</p>




<p>名词就解释完了，这里只要记住一条：<strong>复制指针并不同时复制指针所指向的数据！</strong></p>




<p>3.5<strong>空指针并非空字符串</strong></p>




<p>//这节好像没什么东西好记！</p>




<p>#define NULL 0</p>




<p>3.6<strong>边界计算与不对称边界</strong></p>




<p>关于边界问题也是我经常犯糊涂的问题，今天看了有些收获！</p>




<p>用第一个入界点和第一个出界点来表示一个数值范围。下界是入界点，包括在取值范围之中;上界是出界点，不包括在取值范围之中。这叫不对称边界：</p>




<p>1.取值范围的大小就是上界与下界之差。</p>




<p>2.如果取值范围为空，那么上界等于下界。这是第一条的直接推论。</p>




<p>3.取值范围为空，上界也永远不可能小于下界。</p>




<p>对于问题：整数x满足边界条件x大于等于16且x小于等于37,那么此范围内x的可能取值的个数是多少？//此博客中好像不能出现小于号，因此用文字代替。</p>




<p>下界是16,包含中！上界是38,38是不包含在其中的。因此用上界减去下界38-16=22 因此可得出答案是22。方便快捷！</p>




<p>对于数组buffer[N],&amp;buffer[N]是一个地址，C语言中引用这个无效元素的地址是允许的，可利用于本例中的不对称边界原则，但引用该元素则是非法的！ //这个不对称边界原则在STL中也有应用！</p>




<p>3.7<strong>求值顺序</strong></p>




<p>C语言中只有四个运算符（&amp;&amp; || ?: ,)存在规定的求值顺序。而其它运算符对其操作数求值的顺序是未定义的，特别地，赋值运算符并不保证任何求值顺序。因此，在编程中不要对求值顺序作假设！</p>




<p>3.8<strong>运算符&amp;&amp;，|| 和 !</strong></p>




<p>3.9<strong>整数溢出</strong></p>




<p>注意有符号数的计算！</p>




<p>3.10<strong>为main函数提供返回值</strong></p>




<p>这个不用说了，gcc已经明确要求main要返回值！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C陷阱与缺陷(2)]]></title>
    <link href="http://lerosua.github.io/blog/2006/04/27/c%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B72/"/>
    <updated>2006-04-27T00:00:00+08:00</updated>
    <id>http://lerosua.github.io/blog/2006/04/27/c陷阱与缺陷2</id>
    <content type="html"><![CDATA[<p><p>第二章：语法陷阱</p>
<p>2.1<strong>理解函数声明</strong></p>
<p><strong>int  f,g; </strong>声明<strong>f，g</strong>的类型为整型.</p>
<p><strong>int ((f)); </strong>当对<strong>((f))</strong>求值时，<strong>((f))</strong>的类型为整型，由此可推知<strong>f</strong>也是整型。</p>
<p><strong>int *pf;</strong> 这个声明中，<strong>*pf</strong>是一个整型数，所以<strong>pf</strong>是一个指向整型数的指针。</p>
<p><strong>int *g(),(*h)();</strong></p>
<p>对于*g(),因为()的优先级高于*，*g()就是*(g());令pf=g(),则*g()就是*pf,整个表达式变成 int *pf; 因此可知pf 是一个指向整型数的指针。由此可知对g()的求值结果是一个指向整型数的指针，也就是说g()的返回值是指向整型数的指针。最后得出，g是一个函数，该函数的返回值类型为指向整型数的指针。</p>
<p>对于(*h)()，令pf=(*h),则 pf() , 很明显看出，pf是一个返回值为int的函数。即*h是一个返回值为int的函数，因此h就是这个函数的指针，即h为返回值为int的函数的指针。</p>
<p><strong>int (*h)();</strong> 表示h是一个指向返回值为整型的函数的指针，因此：</p>
<p><strong>(int (*)())</strong>  表示一个“指向返回值为整型的函数的指针”的类型转换符。</p>
<p>假定fp是一个函数,调用fp所指向的函数为: (*fp)();ANSI标准允许程序员将上式简写成fp()。但要记住这只是一种简写形式。</p>
<p>*fp()实际上与*(fp())的含义完全一致，ANSI C把它作为 *((*fp)())的简写形式。</p>
<p>(void (*)()) 0; 将常数0转型为“指向void的函数的指针”类型。</p>
<p>对于 fp(),可变成：(*(void(*)()) 0)();</p>
<p>//有点玄而上学了！</p>
<p>2.2<strong>运算符的优先级问题</strong></p>
<p>这个问题在第一章的时候提了一下！现在举个自己的例子!</p>
<p>r=hi&gt;&gt;4+low ;</p>
<p>我曾经天真地认为hi会先右移四位然后才和low相加。但错误狠狠地教训了我！这个表达式的顺序是hi右移了4+low个位。”+“的运算符的优先级大于“&gt;&gt;”的优先级!</p>
<p>具体的就不说了！记住下面两点：</p>
<p>1.任何一个逻辑运算符的优先级低于任何一个关系运行符。</p>
<p>2.移位运算符的优先级比算术运行符要低，但是比关系运算符要高。</p>
<p>另加自己的一条：<strong>如果不确定运算符的优先级，那就给你想先执行的语句加上括号！</strong>方便阅读并且保险！</p>
<p>2.3<strong>注意作为语句结束标志的分号</strong></p>
<p>(1) if(x[i]&gt;big);</p>
<p>(2)  big=x[i];</p>
<p>注意，第二句和第一句的if没有关系！因为第一句的if之后有了一个分号，表示if语句判断之后执行了一个空语句。然后到了第二句！</p>
<p>再来看看少了分号的情况！</p>
<p>if(n&gt;3)</p>
<p>return</p>
<p>logrec.date = x[0] ;</p>
<p>logrec.time = x[1];</p>
<p>程序原意是n大于3时就返回！但在return后面少了一个分号，程序就变成了n大于3时返回logrec.date的值了！</p>
<p>struct logrec{</p>
<p>int date;</p>
<p>int time;</p>
<p>int code;</p>
<p>}</p>
<p>main()</p>
<p>{</p>
<p>}</p>
<p>在这里，结构体后面少了个分号，程序变成了main函数的返回值是上面据说的结构体！这些都是不得不注意的问题！</p>
<p>2.4 <strong>switch语句</strong></p>
<p>switch后面的case会顺序执行，因为C语言把case标号当成真正意义上的标号，程序的控制流程会径直通过case标号，而不受到任何影响！因此需要在每个case后面加上break来退出执行流！</p>
<p>2.5 <strong>函数调用</strong></p>
<p>C语言要求在函数调用的时候即使函数不带参数，也应该包括参数列表，因此，如果f是一个函数:</p>
<p>f(); 是一个函数调用语句，而</p>
<p>f; 是一个什么也不做的语句，这个语句计算函数f的地址，却没有调用这个函数！</p>
<p>2.6 <strong>“悬挂”else引发的问题</strong></p>
<p>没啥好说的，注意if和else的对应问题就可以了！写代码的时候注意好缩进能比较好地防止这个问题！或者是即使没有else语句对应的if语句也写上去，只为了对应，写上去的else执行空语句就可以了！
</p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开篇]]></title>
    <link href="http://lerosua.github.io/blog/2006/04/23/%E5%BC%80%E7%AF%87/"/>
    <updated>2006-04-23T00:00:00+08:00</updated>
    <id>http://lerosua.github.io/blog/2006/04/23/开篇</id>
    <content type="html"><![CDATA[<p><p>博客的一个作用</p>
<p>发现csdn的博客通常都是将博客用来作读书笔记的！我也发现这样做是有些好处的，起码可以提醒自己要记得看书。（我总是看一半就没看下去）并且看完的的书的章节做些笔记是对记忆很有用处的事情！之后回来看，无论写了些什么都总会因此而想起当时的记忆。这的确是件不坏的事情。因为人的记忆其实是很不可靠的东西，因此做笔记是很有必要的！另外也可以为博客充充数！呵呵！</p>
<p>新建了读书笔记这个类别，主要是针对自己的！
</p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C陷阱与缺陷(1)]]></title>
    <link href="http://lerosua.github.io/blog/2006/04/23/c%E9%99%B7%E9%98%B1%E4%B8%8E%E7%BC%BA%E9%99%B71/"/>
    <updated>2006-04-23T00:00:00+08:00</updated>
    <id>http://lerosua.github.io/blog/2006/04/23/c陷阱与缺陷1</id>
    <content type="html"><![CDATA[<p>第一章 词法陷阱</p>




<p>1.1 <strong>=不同于==</strong></p>




<p>注意赋值操作符与比较操作符的区别，注意操作符之间的优先级问题。</p>




<p>1.3 <strong>词法中的贪心法</strong></p>




<p>a+++b 等价于 (<strong>a++)+ </strong>  b</p>




<p><strong>y=x/*p</strong>   编译器可能会认为/*是注释的开始，而不是说x 除以p指向的值，这里会产生歧义。因此最好用括号括起来：<strong>y=x/(*p)</strong></p>




<p>1.5<strong>字符与字符串</strong></p>




<p>用单引号引起的一个字符实际上代表的是一个整数。整数值对应于该字符在编译器采用的字符集中的序列值。</p>




<p>用双引号引起的字符串，代表的是一个指向无名数组起始字符的指针，该数组被双引号之间的字符以及一个额外的二进制值的字符  " \ 0 "初始化。</p>

]]></content>
  </entry>
  
</feed>
